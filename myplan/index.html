<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title></title>
<link href="css/style1.css" type="text/css" rel="stylesheet">
<script src="js/jquery-1.8.0.min.js" ></script>
<script src="js/fastclick.min.js" ></script>
<script src="js/circle.js" type="text/javascript"></script>
</head>
<body>
<!--<iframe id="geoPage" width=0 height=0 frameborder=0  style="display:none;" scrolling="no" src="https://apis.map.qq.com/tools/geolocation?key=D7BBZ-HERW6-V26SZ-M35SP-5XPBT-LSFOD&referer=myapp">
</iframe> 
    <div id="out">
	    <div id="first"><a href="javascript:;"><img src="img/internet.png"></a></div>
	    <div id="second"><a href="javascript:;"><img src="img/fax.png"></a></div>
	    <div id="third"><a href="javascript:;"><img src="img/map.png"></a></div>
	</div>
	<div id="nav">
	    <img src="img/home.png">
	</div>-->
	<div id="result">
	    
	</div>
	<script>
		let time = 1522379096000;
		let startTime = changedate(time, 'yyyy-MM-dd');
		let endTime = getNewDay(startTime, 90);
					
		console.log(time)
		console.log(startTime)
		function changedate(time, format) {
		    if (time == "" || time == null) {
		        return ""
		    }
		    var t = new Date(time);
		    console.log(t)
		    var tf = function (i) { return (i < 10 ? '0' : '') + i };
		    return format.replace(/yyyy|MM|dd|HH|mm|ss/g, function (a) {
		        switch (a) {
		            case 'yyyy':
		                return tf(t.getFullYear());
		                break;
		            case 'MM':
		                return tf(t.getMonth() + 1);
		                break;
		            case 'dd':
		                return tf(t.getDate());
		                break;
		            case 'HH':
		                return tf(t.getHours());
		                break;
		            case 'mm':
		                return tf(t.getMinutes());
		                break;
		            case 'ss':
		                return tf(t.getSeconds());
		                break;
		        }
		
		    })
		};
		// 中国标准时间转换为日期格式结束
		
		//给日期加90天
		function getNewDay(dateTemp, days) {  
		    var dateTemp = dateTemp.split("-");  
		    var nDate = new Date(dateTemp[1] + '-' + dateTemp[2] + '-' + dateTemp[0]); //转换为MM-DD-YYYY格式    
		    var millSeconds = Math.abs(nDate) + (days * 24 * 60 * 60 * 1000);  
		    var rDate = new Date(millSeconds);  
		    var year = rDate.getFullYear();  
		    var month = rDate.getMonth() + 1;  
		    if (month < 10) month = "0" + month;  
		    var date = rDate.getDate();  
		    if (date < 10) date = "0" + date;  
		    return (year + "-" + month + "-" + date);  
		}  
		
		let [count,onSale] = [1,2];
    	$('#result').append(`There are <b>${count}</b> items in your basket, <em>${onSale}</em> are `);
    	
    	function log(x,{y=8}){
    		console.log(x,y)
    	}
		log('hello',{y:'1222'});
		
		// 写法一
		function m1(x, y = 0) {
		  console.log(x, y);
		}
		m1(1);
		
		let off = ({x,y = 8}) => {
			console.log(x);
			console.log(x*y);
		};
		off({x:2,y:9});
		/*var Rtm = function() {
			var RtmClick = function() {
				console.log('RtmClick');
			};
			return {
				init: function() {
					RtmClick();
				}
			};
		}();
		Rtm.init();*/
		/*let indexClick = () => {
				console.log('indexClick');
			}*/
		var Rtm = function() {
			let RtmClick = () => {
				console.log('RtmClick');
			};
			let indexRtm = 4444; 
			return {
				init: function() {
					RtmClick();
				}
			};
		}();
		Rtm.init();
		const indexMain = () => {
			let index = 3322;
			init = () =>{
				console.log(index);
			}
			init();
		}
		indexMain();
		
		function f(x, y, z) {
		  console.log(x, y, z);//0 1 undefined
		}
		let args = [0, 1];
		f(...args);
		
		var a = ['A', 'B', 'C'];
		var s = new Set(['A', 'B', 'C']);
		var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
		for (var x of a) { // 遍历Array
		    DoWrite(x);
		}
		for (var x of s) { // 遍历Set
		    DoWrite(x);
		}
		for (var x of m) { // 遍历Map
			DoWrite(x);
		    DoWrite(x[0] + '=' + x[1]);
		}
		let arrayLike = {
		    '0': '1',
		    '1': '2',
		    '2': '3',
		    length: 3
		};
		
		
		
		let aLLike = [].copyWithin.call({length: 5, 3: 1}, 0, 3)
		
		
		
		const contains = (() =>
		  Array.prototype.includes
		    ? (arr, value) => arr.includes(value)
		    : (arr, value) => arr.some(el => el === value)
		)();
		console.log(contains(['foo', 'bar'], 'bar'))
		
		let ff = (x,y) => {
			return {x,y};
		}
		
		console.log(ff(1,2))
		
		let o = {
			index(){
				o.name();
				console.log('index')
			},
			name(){
				console.log('name')
			},
			init(){
				return o.index()
			}
		}
		o.init();
		let [name,password,age] = ['zhang','111','20'];
		
		let birth = {
			name,
			password,
			age
		};
		console.log(birth)
		
		//对象合并
		let [target,source] = [{a:1,b:2,c:2},{c:4}];
		
		console.log(Object.assign(target,source))
		console.log(Object.entries(target))
		
		
		//克隆  克隆对象保持继承连
		function clone(origin) {
		  let originProto = Object.getPrototypeOf(origin);
		  return Object.assign(Object.create(originProto), origin);
		}
		//克隆  只能克隆原始对象自身的值,不能克隆它继承的值
		function clone(origin) {
		  return Object.assign({}, origin);
		}
		
		//合并多个对象    将多个对象合并到某个对象
		const merge = (...sources)=>Object.assign({},...sources)
		
		let [propo,obj] = [{},{x:10}];
		Object.setPrototypeOf(obj,propo);
		propo.y = 20;
		console.log(obj.y)
		console.log(Object.getPrototypeOf(obj))
		const pro = {
			foo:'100',
			name:'200'
		}
		const objb = {
		  foo: 'world',
		  find() {
		    return super.name;
		  }
		};
		Object.setPrototypeOf(objb,pro)
		console.log(objb.find())
		console.log(Object.keys(pro));
		console.log(Object.values(pro));
		
		
		//Object.entries的基本用途是遍历对象的属性
		for (let [k, v] of Object.entries(pro)) {
		  console.log(k,v);
		}
		//Object.entries方法的另一个用处是，将对象转为真正的Map结构。
		const obbj = { foo: 'bar', baz: 42 };
		const map = new Map(Object.entries(obbj));
		map // Map { foo: "bar", baz: 42 }
		
		//变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。
		let { xx, y, ...z } = { xx: 1, y: 2, a: 3, b: 4 };
		console.log(xx,y,z);
		let [asd,...e] = ['111','333','222'];
		console.log(asd,e)
		
		let { aa, bb, ...cc } = { aa: 123, bb: 456, dd: 78, vv: 99};
		
		console.log(cc);
		
		
		
		
		
		const obbjj = {};

		let fooj = Symbol("foo");
		
		Object.defineProperty(obbjj, fooj, {
		  value: "foob",
		});
		for (let i in obbjj) {
			console.log('111')
		  console.log(i); // 无输出
		}
		console.log(fooj);
		console.log(obbjj);
		
		//Reflect.ownKeys  返回所有类型的键名，包括常规键名和Symbol键名
		let objjj = {
		  [Symbol('my_key')]: 1,
		  enum: 2,
		  nonEnum: 3
		};
		
		Reflect.ownKeys(objjj)
		//  ["enum", "nonEnum", Symbol(my_key)]
		
		
		//Set  数据结构set，类似于数组，但是成员的值都是唯一的，没有重复的值
		
		const ss = new Set();
		
		[1,2,3,4,'1',43,2].forEach(x => ss.add(x));  //{1, 2, 3, 4, "1", 43}
		for (let i of ss) {
		}
		
		
		/*去除数组中重复的
		add(value)：添加某个值，返回 Set 结构本身。
		delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
		has(value)：返回一个布尔值，表示该值是否为Set的成员。
		clear()：清除所有成员，没有返回值。*/
		//Array.from() 也可将set转为数组形式
		/*const setRepeat = (set) => [...new Set(set)];*/  //[...Arr]  返回数组，set转数组
		const setRepeat = (set) => new Set(set);
		
		let setA = [1,2,3,4,1,43,2],
			setB = [5,5,6,4,7],
			setC = [...setRepeat([...setA,...setB])],
			setD = setRepeat([...setA,...setB]);
		
		console.log(setC) // [1, 2, 3, 4, 43, 5, 6, 7]
		console.log(Array.from(setD)) // [1, 2, 3, 4, 43, 5, 6, 7]
		console.log([...setD.add(99)]) //[1, 2, 3, 4, 43, 5, 6, 7, 99]
		console.log(setD.delete(99)) //true
		console.log(setD.has(99)) //false
		//console.log(setD.clear()) //undefined
		console.log([...setD]) //[]
		
		//遍历操作
		//keys()：返回键名的遍历器
		//values()：返回键值的遍历器
		//entries()：返回键值对的遍历器
		//forEach()：使用回调函数遍历每个成员
		let setergodic = new Set(['red', 'green', 'blue']);

		for (let item of setergodic.keys()) {
		  console.log(item);
		}
		// red
		// green
		// blue
		
		for (let item of setergodic.values()) {
		  console.log(item);
		}
		// red
		// green
		// blue
		
		for (let item of setergodic.entries()) {
		  console.log(item);
		}
		// ["red", "red"]
		// ["green", "green"]
		// ["blue", "blue"]
		
		//扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。
		let arr = [3, 5, 2, 2, 5, 5];
		let unique = [...new Set(arr)];
		// [3, 5, 2]
		
		
		//数组的map和filter方法也可以间接用于 Set 了。
		let set = new Set([1, 2, 3]);
		set = new Set([...set].map(x => x * 2));
		// 返回Set结构：{2, 4, 6}
		
		let sett = new Set([1, 2, 3, 4, 5]);
		sett = new Set([...sett].filter(x => (x % 2) == 0));
		// 返回Set结构：{2, 4}
		
		let aaaa = new Set([1, 2, 3]);
		let bbbb = new Set([4, 3, 2]);
		
		// 并集
		let union = new Set([...aaaa, ...bbbb]);
		// Set {1, 2, 3, 4}
		
		// 交集
		let intersect = new Set([...aaaa].filter(x => bbbb.has(x)));
		// set {2, 3}
		
		// 差集
		let difference = new Set([...aaaa].filter(x => !bbbb.has(x)));
		// Set {1}
		
		
		//在遍历操作中，同步改变原来的set结构
		// 方法一
		let setS = new Set([1, 2, 3]);
		setS = new Set([...setS].map(val => val * 2));
		// set的值是2, 4, 6
		// 方法二
		let setU = new Set([1, 2, 3]);
		setU = new Set(Array.from(setU, val => val * 2));
		// set的值是2, 4, 6
		
		//WeakSet WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

		//首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
		//WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。
		
		const ws = new WeakSet();
			
		//WeakSet 结构有以下三个方法。
		//WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
		//WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
		//WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 

		const wws = new WeakSet();
		const wsobj = {};
		const wsfoo = {};
		
		wws.add(window);
		wws.add(wsobj);
		
		wws.has(window); // true
		wws.has(wsfoo);    // false
		
		wws.delete(window);
		wws.has(window);    // false
		
		
		
		//Map  本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。
		const mAp = new Map();
		const oAp = {p: 'Hello World'};
		
		mAp.set(oAp, 'content')
		mAp.get(oAp) // "content"
		console.log(mAp)
		mAp.has(oAp) // true
		/*mAp.delete(oAp) // true
		mAp.has(oAp) // false*/
		
		const mapArr = new Map([
		  ['name', '张三'],
		  ['title', 'Author']
		]);
		console.log(mapArr)
		mapArr.size // 2
		mapArr.has('name') // true
		mapArr.get('name') // "张三"
		mapArr.has('title') // true
		mapArr.get('title') // "Author"
		
		const setMap = new Set([
		  ['foo', 1],
		  ['bar', 2]
		]);
		const setMap1 = new Map(setMap);
		setMap1.get('foo') // 1
		
		const setMap2 = new Map([['baz', 3]]);
		const setMap3 = new Map(setMap2);
		setMap3.get('baz') // 3
		setMap1.set([a], 555);
		
		console.log(setMap1)
		console.log(setMap1.get(Array(1)))
		
		const map0 = new Map()
		  .set(1, 'a')
		  .set(2, 'b')
		  .set(3, 'c');
		
		const map1 = new Map(
		  [...map0].filter(([k, v]) => k < 3)
		);
		
		console.log(map1)
		for (let v of map1.keys()) {
			console.log(v)
		}
		for (let v of map1.values()) {
			console.log(v)
		}
		for (let [k,v] of map1.entries()) {
			console.log(k,v)
		}
		// 产生 Map 结构 {1 => 'a', 2 => 'b'}
		
		const map2 = new Map(
		  [...map0].map(([k, v]) => [k * 2, '_' + v])
		    );
		// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}
		
		//forEach方法还可以接受第二个参数，用来绑定this。
		
		const reporter = {
		  report: function(key, value) {
		    console.log("Key: %s, Value: %s", key, value);
		  }
		};
		
		map.forEach(function(value, key, map) {
		  this.report(key, value);
		}, reporter);
		
		//上面代码中，forEach方法的回调函数的this，就指向reporter。
		
		//Map 转为数组
		const myMap1 = new Map()
		  .set(true, 7)
		  .set({foo: 3}, ['abc']);
		[...myMap1]
		// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
		
		//数组 转为 Map
		new Map([
		  [true, 7],
		  [{foo: 3}, ['abc']]
		])
		// Map {
		//   true => 7,
		//   Object {foo: 3} => ['abc']
		// }
		
		//Map 转为对象
		function strMapToObj(strMap) {
		  let obj = Object.create(null);
		  for (let [k,v] of strMap) {
		    obj[k] = v;
		  }
		  return obj;
		}
		
		const myMap3 = new Map()
		  .set('yes', true)
		  .set('no', false);
		strMapToObj(myMap3)
		// { yes: true, no: false }
		
		//对象转为Map
		function objToStrMap(obj) {
		  let strMap = new Map();
		  for (let k of Object.keys(obj)) {
		    strMap.set(k, obj[k]);
		  }
		  return strMap;
		}
		
		objToStrMap({yes: true, no: false})
		// Map {"yes" => true, "no" => false}
		
		//Map 转为 JSON
		//Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。
		function strMapToJson(strMap) {
		  return JSON.stringify(strMapToObj(strMap));
		}
		
		let myMap33 = new Map().set('yes', true).set('no', false);
		strMapToJson(myMap33)
		// '{"yes":true,"no":false}'
		
		//另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。
		function mapToArrayJson(map) {
		  return JSON.stringify([...map]);
		}
		
		let myMap22 = new Map().set(true, 7).set({foo: 3}, ['abc']);
		mapToArrayJson(myMap22)
		// '[[true,7],[{"foo":3},["abc"]]]'
		
		//JSON 转为 Map
		function jsonToStrMap(jsonStr) {
		  return objToStrMap(JSON.parse(jsonStr));
		}
		
		jsonToStrMap('{"yes": true, "no": false}')
		// Map {'yes' => true, 'no' => false}
		
		
		//但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。
		//这往往是 Map 转为数组 JSON 的逆操作。
		function jsonToMap(jsonStr) {
		  return new Map(JSON.parse(jsonStr));
		}
		
		jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
		// Map {true => 7, Object {foo: 3} => ['abc']}
		
		//Iterator 遍历器
		/*（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

		（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。

		（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。

		（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。
		 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。
		 其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。*/
		
		var it = makeIterator(['a', 'b']);
console.log(it.next())
		it.next() // { value: "a", done: false }
		it.next() // { value: "b", done: false }
		it.next() // { value: undefined, done: true }
		
		function makeIterator(array) {
		  var nextIndex = 0;
		  return {
		    next: function() {
		      return nextIndex < array.length ?
		        {value: array[nextIndex++], done: false} :
		        {value: undefined, done: true};
		    }
		  };
		}
		//可去掉{done：true}
		/*function makeIterator(array) {
		  var nextIndex = 0;
		  return {
		    next: function() {
		      return nextIndex < array.length ?
		        {value: array[nextIndex++]} :
		        {done: true};
		    }
		  };
		}*/
		
		//原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。
		//for...in循环读取键名，for...of循环读取键值
		var arrArr = ['a', 'b', 'c', 'd'];
		for (let a in arrArr) {
		  console.log(a); // 0 1 2 3
		}
		
		for (let a of arrArr) {
		  console.log(a); // a b c d
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		function DoWrite(title){
			document.write(title+'</br>');
		}
		/*$.ajax({
			    url:'https://www.ipip5.com/today/api.php?type=json',
			    type:'get',
				dataType: 'jsonp',
				jsonp:"callback", 
				contentType: 'application/json',
				jsonpCallback:"success_jsonpCallback", 
				timeout:3000, 
				dataFilter:function(json,type){    
			       console.log(json)
			        return json;    
			        
			    },
			    success:function(data,type){
			    
			    },      
			    error:function(XMLHttpRequest,textStatus,errorThrown){      
			     console.log(textStatus)
			    } 
			});*/
			
				/*var odata = {
		     		'apikey':'0b2bdeda43b5688921839c8ecb20399b',
		     		'city':'city',
		     		'start':1,
		     		'count':'10',
		     		'client':'',
		     		'udid':''
		     	}
			   $.ajax({
			    url:'https://api.douban.com/v2/movie/in_theaters',
			    type:'get',
			    data:odata,
				dataType: 'jsonp',
				jsonp:"callback", 
				
				jsonpCallback:"success_jsonp", 
				dataFilter:function(json,type){    
			        console.log("jsonp.filter:"+json);    
			        console.log("jsonp.type:"+type);    
			        return json;    
			    },
			    success:function(data){
			    	console.log(data)
			    }
			   }); 
			   var qdata = {
		     		'apikey':'0b2bdeda43b5688921839c8ecb20399b',
		     		'city':'上海',
		     		'start':2,
		     		'count':'10',
		     		'client':'',
		     		'udid':''
		     	}
			   $.ajax({
			    url:'https://api.douban.com/v2/movie/in_theaters',
			    type:'get',
			    data:qdata,
				dataType: 'jsonp',
				jsonp:"callback", 
				jsonpCallback:"success_jsonp", 
			    success:function(data){
			    	console.log(data)
			    }
			   }); 
			    $.ajax({
				    url:'http://api.douban.com/v2/movie/subject/26942674',
				    type:'get',
					dataType: 'jsonp',
					jsonp:"callback", 
					jsonpCallback:"succe_jsonp", 
				    success:function(data){
				    	console.log(data)
				    }
			   }); 
		$.ajax({
				    url:'https://interface.meiriyiwen.com/article/today',
				    type:'get',
				    data:{'dev':'1'},
					dataType: 'json', 
				    success:function(data){
				    	console.log(data)
				    	$('.title').html()
				    }
			   }); */
	</script>
</body>
</html>
